<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>:bulb: Researches on Haruaki Tamada</title><link>https://tamada.github.io/research/</link><description>Recent content in :bulb: Researches on Haruaki Tamada</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright &amp;copy; by Haruaki Tamada. Made with [Hugo](https://gohugo.io/). Deployed to [GitHub Pages](https://pages.github.com/).</copyright><lastBuildDate>Fri, 27 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://tamada.github.io/research/index.xml" rel="self" type="application/rss+xml"/><item><title>Git/GitHub Operation Support for Novice Programmers</title><link>https://tamada.github.io/research/git_operation_supports/</link><pubDate>Fri, 27 Aug 2021 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/git_operation_supports/</guid><description>&lt;h2 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;p&gt;Learning the git and GitHub operation is difficult for novice programmers.
Since even programming is a pretty complicated task, it becomes challenging to consider various kinds of operation except programming, for example, good commit, pull requests, and etc.
However, the recent development process ordinary manages product versions with SCM such as &lt;code&gt;git&lt;/code&gt;.
Therefore, it requires the novices should learn them as soon as possible.&lt;/p&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/git_operation_supports/features.png"/></item><item><title>Fast comparisons of the birthmarks</title><link>https://tamada.github.io/research/birthmark_fast_comparison/</link><pubDate>Sat, 15 Feb 2020 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/birthmark_fast_comparison/</guid><description>&lt;h2 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;p&gt;The software birthmarks were proposed for detecting the software theft from a large number of suspected programs.
The birthmark is a technique to compare the extracted characteristics as the software birthmarks, and compute similarities between two birthmarks.
The conventional birthmarks require a much time by increasing the target programs for comparison.
Therefore, it is the bottleneck of the conventional birthmarking technique.
In this paper, we propose a method for reducing total processing time by introducing the narrowing phase between conventional extracting and comparison phases.
The narrowing phase employs the fast but rough comparison algorithm in order to eliminate unrelated programs.&lt;/p&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/birthmark_fast_comparison/features.png"/></item><item><title>Identifying the applied obfuscator</title><link>https://tamada.github.io/research/identifying_applied_obfuscator/</link><pubDate>Mon, 27 Jan 2020 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/identifying_applied_obfuscator/</guid><description>&lt;h2 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;p&gt;Recently, to prevent cracking, the various protection methods have been proposed.
One of the protection methods is the obfuscation method.
Obfuscation method changes the program into hard to understand for hiding secret information in the program.&lt;/p&gt;
&lt;p&gt;On the other hand, de-obfuscation is an interesting research topic for protecting the software.
Since, though vulnerable protection methods are dangerous, measuring the robustness of the method was not discussed.&lt;/p&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/identifying_applied_obfuscator/features.png"/></item><item><title>Development support bot</title><link>https://tamada.github.io/research/development_support_bot/</link><pubDate>Sun, 20 Oct 2019 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/development_support_bot/</guid><description>&lt;h3 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h3&gt;
&lt;p&gt;This research topic aims to build a helpful bot for the software development.
Also, the topic focuses on the bot on the Social Coding Platform in the social network services.
The one goal of the topic is to build a bot for gently helping GitHub flow.&lt;/p&gt;

&lt;h3 class="relative group"&gt;:books: Publications
 &lt;div id="books-publications" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#books-publications" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;宮崎 光，玉田 春昭，CUIツールの開発支援サービスとしての再構築手順の提案”，信学技法，Vol.119，No.246, SS2019-14, pp.7–12, October 2019（熊本）.&lt;/li&gt;
&lt;li&gt;玉田 春昭，”初学者向けGitHub flow学習支援”，ソフトウェアシンポジウム2019 ワークショップ 討論テーマ（2）実証的ソフトウェア工学によるプログラミング教育とソフトウェア工学教育，August 2019.（東京）&lt;/li&gt;
&lt;li&gt;Ko Miyazaki, Haruaki Tamada, “Identifying Users in the Bridging Service between Two Different Chat Services using User Icons,” In Proc. HCI International 2019, Digital Human Modeling and Applications in Health, Safety, Ergonomics and Risk Management. Healthcare Applications, (HCII2019), Lecture Notes in Computer Science, vol 11582, 24-31 July 2009. (Orlando, FL, USA).&lt;/li&gt;
&lt;li&gt;柳川 龍太郎，西尾 泰介，玉田 春昭，”システム開発初心者のためのGitHub flow学習支援システム”，第25回ソフトウェア工学の基礎ワークショップ（FOSE2018），November 2018（函館，ポスター発表）&lt;/li&gt;
&lt;li&gt;宮崎 光，玉田 春昭，”異なるチャットシステム間でメッセージ送信可能なシステムの構築”，第17回情報科学技術フォーラム（Forum on Information Technology 2018）(FIT 2018)，September 2018.（福岡）&lt;/li&gt;
&lt;li&gt;西尾 泰介，柳川 龍太郎，玉田 春昭，”初学者を対象としたGitHub flow支援ボット”，ソフトウェアシンポジウム2018 ワークショップ 討論テーマ（4）ソーシャルコーディングのための実証的ソフトウェア工学，September 2018.（東京）&lt;/li&gt;
&lt;li&gt;玉田 春昭，”ソーシャルコーディングプラットフォーム上のサービス連携のためのメタボット’‘，ウィンターワークショップ2018，January 2018.（広島）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 class="relative group"&gt;:mag_right: Related Research Topics
 &lt;div id="mag_right-related-research-topics" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#mag_right-related-research-topics" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../project_as_a_city" &gt;Project as a City&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../software_development_with_ai" &gt;Mining Software Repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../characteristics_of_developers" &gt;Characteristics of the developers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 class="relative group"&gt;:handshake: Collaborators
 &lt;div id="handshake-collaborators" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#handshake-collaborators" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://se-naist.jp" target="_blank" rel="noreferrer"&gt;K. Matsumoto&lt;/a&gt;@NAIST&lt;/li&gt;
&lt;/ul&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/development_support_bot/features.png"/></item><item><title>Project as a City</title><link>https://tamada.github.io/research/project_as_a_city/</link><pubDate>Fri, 20 Sep 2019 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/project_as_a_city/</guid><description>&lt;h2 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;p&gt;Social coding platforms (SCPs) have realized &lt;em&gt;spontaneous software evolution&lt;/em&gt;, where new source code and ideas are spontaneously proposed by altruistic developers.
Although there are many projects operated by active communities performing spontaneous evolution, it is yet unclear that how such successful projects and communities have been formed and governed.
In this paper, we propose a method that can investigate the history of every project in the SCP.
Introducing the concept of &lt;em&gt;project as a city&lt;/em&gt;, we consider every project in the SCP as a city, where a government and citizens develop a city through collaborative activities.
We then identify essential attributes that characterize a state of a city.
For each attribute, we develop metrics that quantify the state $S(p,t)$ of a project $p$ at time $t$.
An experimental evaluation investigating GitHub projects of famous code editors shows that the proposed metrics well visualize the history of the projects from essential perspectives of a city.&lt;/p&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/project_as_a_city/features.png"/></item><item><title>Auto-extraction of Dynamic Birthmarks</title><link>https://tamada.github.io/research/automatic_extraction_of_dynamic_birthmarks/</link><pubDate>Mon, 15 Jul 2019 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/automatic_extraction_of_dynamic_birthmarks/</guid><description>&lt;h2 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;p&gt;The software birthmark methods are proposed to find the stolen software from the huge number of suspects.
The software birthmark methods are classified into two manners, static and dynamic manners.
Different from the static birthmarks, dynamic birthmarks require inputs since they base on runtime behaviors.
Also, the dynamic birthmark varies depending on the inputs, therefore, it is difficult to extract beforehand.
Hence the extraction cost of the dynamic birthmarks is generally high than the static birthmarks.
This paper focuses on unit test codes in a project in order to extract the dynamic birthmarks beforehand, and reduce the extraction cost.
The experiments evaluated the credibility and resilience performance of the birthmarks.
The performance evaluation showed good results, the similarities were greater than 0.8 between most recent two versions of the same products, and were under 0.355 among different projects.
In the cost evaluation, the proposed method can reduce the extraction cost of dynamic birthmarks.&lt;/p&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/automatic_extraction_of_dynamic_birthmarks/features.png"/></item><item><title>De-obfuscate IRM</title><link>https://tamada.github.io/research/deobfuscating_identifier_renaming/</link><pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/deobfuscating_identifier_renaming/</guid><description>&lt;h2 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;p&gt;The obfuscation methods are often used to hide sensitive information in software.
Especially, an identifier renaming method (IRM) is well used because it is easy to implement.
IRM is one of the obfuscation methods, and to change the names of function, and variables into meaningless one.
However, if we can restore the identifiers to the original names, IRM is invalidated.
One of the serious problems about IRM is that the tolerance against de-obfuscation is not discussed.
This paper tries to de-obfuscate IRMed programs.
Thereby, this paper evaluates the tolerance and effectiveness of IRM.
From the experimental evaluation, the proposed method can restore the 49.71 % of method names to the original verbs.
Furthermore, focusing on the meanings of verbs, the proposed method recommends the verbs of similar meanings to the original verbs in 57.01 % of methods.&lt;/p&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/deobfuscating_identifier_renaming/features.png"/></item><item><title>Evaluating students in programming courses</title><link>https://tamada.github.io/research/evaluation_programming_course/</link><pubDate>Mon, 15 Jan 2018 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/evaluation_programming_course/</guid><description>&lt;h2 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;p&gt;It is crucial for educators to understand pitfalls for novice programmers in programming education at computer science course.
By giving well-timed advice to students who fall into a pitfall, educators are able to achieve efficient teaching and keep up their students&amp;rsquo; motivation.
However, so far, it is less well-understood how novice students edit source code and why they fall into a pitfall.
In this paper, we analyzed coding patterns of novice students empirically.
We collected programming activities by students on exercises of programming course, and then performed qualitative and quantitative analysis.
In qualitative analysis, experienced programmers analyzed patterns of the novice programmers manually.
In quantitative analysis, we focused on transtions of the edit distance between a source code of each student under development and a correct source code in a programming class.
As a result, we confirmed coding patterns of novice programmers in case of falling into pitfalls, and the characteristics of transitions of edit distance metric in the case that novice students had faced difficulty in understanding the exercise.&lt;/p&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/evaluation_programming_course/features.png"/></item><item><title>Mining Software Repository</title><link>https://tamada.github.io/research/software_development_with_ai/</link><pubDate>Fri, 14 Jul 2017 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/software_development_with_ai/</guid><description>&lt;h2 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;p&gt;This topic is for mining software repositories.
The following surveys were done.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;why do the developers update the build files in the project, and&lt;/li&gt;
&lt;li&gt;how to build the obliging bots for supporting next action.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 class="relative group"&gt;:books: Publications
 &lt;div id="books-publications" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#books-publications" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;鐘ヶ江 由佳，玉田 春昭，畑 秀明，”GitHubにおける言語ごとのビルドファイルの更新理由調査”， 研究報告ソフトウェア工学（SE）, Vol. 2017-SE-196, No.28, July 2017.&lt;/li&gt;
&lt;li&gt;Akira Inokuchi, Haruaki Tamada, Hideaki Hata, and Masateru Tsunoda, &amp;ldquo;Toward Obliging Bots for Supporting Next Actions,&amp;rdquo; In Proc. of the 4th International Conference on Applied Computing &amp;amp; Information Technology (ACIT 2016), pp. 183–188, December 2016 (UNLV, Las Vegas, NV, USA).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 class="relative group"&gt;:mag_right: Related Research Topics
 &lt;div id="mag_right-related-research-topics" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#mag_right-related-research-topics" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../project_as_a_city" &gt;Project as a City&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../characteristics_of_developers" &gt;Characteristics of the developers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 class="relative group"&gt;:handshake: Collaborators
 &lt;div id="handshake-collaborators" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#handshake-collaborators" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hideakihata.github.io/" target="_blank" rel="noreferrer"&gt;H. Hata&lt;/a&gt;@&lt;a href="http://se-naist.jp/" target="_blank" rel="noreferrer"&gt;NAIST SE Lab.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.info.kindai.ac.jp/~tsunoda/" target="_blank" rel="noreferrer"&gt;M. Tsunoda&lt;/a&gt;@Kindai University.&lt;/li&gt;
&lt;/ul&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/software_development_with_ai/features.png"/></item><item><title>Artificiality evaluation of obfuscations</title><link>https://tamada.github.io/research/artificiality_evaluation/</link><pubDate>Mon, 23 Jan 2017 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/artificiality_evaluation/</guid><description>&lt;h2 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;p&gt;This research topic tries to evaluate the artificialities of the obfuscated programs.
We believe that the obfuscation changes the programs into unordinal ones.
This topics evaluates the artificialities by &lt;em&gt;tf-idf&lt;/em&gt; and perplexities.&lt;/p&gt;

&lt;h2 class="relative group"&gt;:books: Publications
 &lt;div id="books-publications" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#books-publications" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;横井 昂典，玉田 春昭，”使用クラスに基づいたTF-IDFによる難読化の不自然さ評価”，2017年暗号と情報セキュリティシンポジウム予稿集 (SCIS 2017)，3D1-4，January 2017.（沖縄，那覇）&lt;/li&gt;
&lt;li&gt;大滝 隆貴，大堂 哲也，玉田 春昭，神崎 雄一郎，門田 暁人，”Javaバイトコード命令のオペコード、オペランドを用いた難読化手法のステルシネス評価”，2014年暗号と情報セキュリティシンポジウム予稿集 (SCIS2014), 2D2-2, January 2014.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 class="relative group"&gt;:mag_right: Related Research Topics
 &lt;div id="mag_right-related-research-topics" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#mag_right-related-research-topics" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../identifying_applied_obfuscator" &gt;Identifying the applied obfuscator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../deobfuscating_identifier_renaming" &gt;De-obfuscate IRM (identifier renaming method)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../evaluation_obfuscation_kolmogorov" &gt;Evaluating obfuscation method by Kolmogorov complexity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../unreadability_evaluation" &gt;Unreadability evaluation of obfuscated programs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 class="relative group"&gt;:handshake: Collaborators
 &lt;div id="handshake-collaborators" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#handshake-collaborators" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.hi.kumamoto-nct.ac.jp/~kanzaki/" target="_blank" rel="noreferrer"&gt;Y. Kanzaki&lt;/a&gt;@Kumamoto National College of Technology&lt;/li&gt;
&lt;/ul&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/artificiality_evaluation/features.png"/></item><item><title>Obfuscation by invokedynamic</title><link>https://tamada.github.io/research/obfuscation_by_invokedynamic/</link><pubDate>Sat, 01 Aug 2015 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/obfuscation_by_invokedynamic/</guid><description>&lt;h2 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;p&gt;This paper proposes an obfuscation method against illegal analysis.
The proposed method tries to build a fake call flow graph from debugging tools.
The call flow graph represents relations among methods and helps understanding of a program.
The fake call flow graph leads misunderstanding of the program.
We focus on a hook mechanism of the method call for changing a callee.
We conduct two experiments to evaluate the proposed method.
First experiment simulates attacks by existing tools: Soot, jad, Procyon, and Krakatau.
The Procyon only succeeded decompilation, the others crashed.
Second experiment evaluates understandability of the obfuscated program by the hand.
Only one subject in the nine subjects answered the correct value.
The experiments shows the proposed method has good tolerance against existing tools, and high difficulty of understanding even if the target program is tiny and simple program.
(Abstract from IJSI 2015)&lt;/p&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/obfuscation_by_invokedynamic/features.png"/></item><item><title>Characteristics of the developers</title><link>https://tamada.github.io/research/characteristics_of_developers/</link><pubDate>Fri, 20 Mar 2015 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/characteristics_of_developers/</guid><description>&lt;h2 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;p&gt;In software development, multiple developers compose a team, and perform a development process.
To succeed the development, understanding developers&amp;rsquo; characteristics are needed.
However, there is no way to measure the characteristics of the developer by quantitative analysis.
Therefore, a project manager often assigns team members based on his/her own sense, considering experience year of them.&lt;/p&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/characteristics_of_developers/features.png"/></item><item><title>Evaluating obfuscation method by Kolmogorov complexity</title><link>https://tamada.github.io/research/evaluation_obfuscation_kolmogorov/</link><pubDate>Sun, 01 Sep 2013 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/evaluation_obfuscation_kolmogorov/</guid><description>&lt;h2 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;p&gt;This paper quantifies the diffuculty of program analysis based on the information theory.
The basic idea is to consider that a program ultimately obscated if instructions appear at random;
that is (1) all instructions has an equal frequency of appearance,
and (2) there is no pattern observed in the instruction sequence.
We quantified (1) based on the entropy and (2) based on the Kolmogorov complexity.
We evaluated the feasibility of our proposal through a case study.&lt;/p&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/evaluation_obfuscation_kolmogorov/features.png"/></item><item><title>Method folding obfuscation</title><link>https://tamada.github.io/research/obfuscation_by_method_folding/</link><pubDate>Mon, 01 Jul 2013 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/obfuscation_by_method_folding/</guid><description>&lt;h2 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;p&gt;To improve tamper resistance of programs against illegal modification, this paper proposes &lt;em&gt;instruction folding&lt;/em&gt; applicable to Java platform.&lt;/p&gt;
&lt;p&gt;In the proposed method, at first, similar methods are selected in a Java program.
Next, these methods are merged into one method and diffs among these methods are stored in the program.
Then, at runtime, when one of the merged methods is executed, diffs are restored by self-modification, which is realized by the Java instrumentation mechanism.
The proposed method is resilient against tampering of folded method.
Even if an adversary modifies the folded method, the program goes crash because the method is repeatedly modified at runtime.&lt;/p&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/obfuscation_by_method_folding/features.png"/></item><item><title>Unreadability evaluation by mental simulation model</title><link>https://tamada.github.io/research/unreadability_evaluation/</link><pubDate>Mon, 24 Sep 2012 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/unreadability_evaluation/</guid><description>&lt;h2 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;p&gt;Obfuscation methods were proposed for protecting programs from cracking.
These methods convert program into incomprehensible one, such as change symbol names from meaningful to meaningless.
As a result, secret information in the program can be hidden.
However, obfuscation methods are not evaluated sufficiently.
This paper evaluates incomprehensibility of the obfuscated programs using queue based virtual mental simulation model (VMSM) which is focused on short term memory in program comprehension.
An experimental evaluation showed that VMSM was able to evaluate the incomprehensibility of data and control flow obfuscation methods.&lt;/p&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/unreadability_evaluation/features.png"/></item><item><title>Applications of software birthmarks</title><link>https://tamada.github.io/research/birthmark_applications/</link><pubDate>Sat, 15 Aug 2009 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/birthmark_applications/</guid><description>&lt;h2 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;p&gt;This research topics shows applications of software birthmarks.
In our publications, we try to classify the programs using extracted software birthmarks.
Because, we believe that the birthmarks shows the functionalities of the programs.&lt;/p&gt;

&lt;h2 class="relative group"&gt;:books: Publications
 &lt;div id="books-publications" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#books-publications" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;牛窓 朋義, 門田 暁人, 玉田 春昭, 松本 健一, “使用クラスに基づくソフトウェアの機能面からの分類”, 信学技報 ソフトウェアサイエンス研究会, Vol.SS2009-17, pp.31-36, August 2009.&lt;/li&gt;
&lt;li&gt;玉田 春昭，森崎 修司，門田 暁人，松本 健一，”バースマークを用いたソフトウェア拡張開発での流用度合いの測定”，情報処理学会第70回全国大会，pp.5-399-400, March 2008.&lt;/li&gt;
&lt;li&gt;Takesi Kakimoto, Akito Monden, Yasutaka Kamei, Haruaki Tamada, Masateru Tsunoda, and Ken-ichi Matsumoto, “Using Software Birthmarks to Identify Similar Classes and Major Functionalities,” In Proc. the 3rd International Workshop on Mining Software Repositories (MSR 2006), pp.171-172, May 2006. (Shanghai, China) 
&lt;a href="https://dl.acm.org/doi/10.1145/1137983.1138026"&gt;
 &lt;div class="inline-flex items-center text-xs font-bold leading-none tracking-tight"&gt;
 &lt;span class="bg-gray-600 text-white px-2 py-1 rounded-l-sm"&gt;Link&lt;/span&gt;
 &lt;span class="bg-green-500 text-white px-2 py-1 rounded-r-sm"&gt;dl.acm.org&lt;/span&gt;
 &lt;/div&gt;
&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2 class="relative group"&gt;:mag_right: Related Research Topics
 &lt;div id="mag_right-related-research-topics" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#mag_right-related-research-topics" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="../birthmark_concept" &gt;Concept of Software Birthmarks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../dynamic_birthmarks" &gt;Dynamic Software Birthmarks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="../birthmark_fast_comparison" &gt;Fast comparisons of the birthmarks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 class="relative group"&gt;:handshake: Collaborators
 &lt;div id="handshake-collaborators" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#handshake-collaborators" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://digi-ana.sakura.ne.jp/" target="_blank" rel="noreferrer"&gt;A. Monden&lt;/a&gt;@&lt;a href="http://analytics.jpn.org/index-e.html" target="_blank" rel="noreferrer"&gt;Software mesurement and analytics laboratory&lt;/a&gt;, Okayama University&lt;/li&gt;
&lt;/ul&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/birthmark_applications/features.png"/></item><item><title>Obfuscation by dynamic name resolution</title><link>https://tamada.github.io/research/obfuscation_by_dnr/</link><pubDate>Tue, 12 Feb 2008 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/obfuscation_by_dnr/</guid><description>&lt;h2 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;p&gt;Name obfuscation is a software protection technique, which renames identifiers in a given program, to protect the program from illegal cracking.
The conventional methods replace names appearing in the declaration part with the meaningless ones.
Therefore, the methods cannot be used to obfuscate names declared in system libraries, since changing such system-defined names significantly deteriorates the program portability.&lt;/p&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/obfuscation_by_dnr/features.png"/></item><item><title>Dynamic birthmarks</title><link>https://tamada.github.io/research/dynamic_birthmarks/</link><pubDate>Tue, 01 Aug 2006 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/dynamic_birthmarks/</guid><description>&lt;h2 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;p&gt;This paper presents a technique of dynamic software birthmarks to support efficient detection of software theft.
A dynamic birthmark $f(p, I)$ is a set of unique and native characteristics of a program $p$, obtained by executing $p$ with a given input $I$.
For a pair of
software $p$ and $q$, if $f(p, I) = f(q, I)$ holds, $q$ is suspected as a copy of $p$.
In this paper, we propose two kinds of dynamic birthmarks, EXESEQ and EXEFREQ which use execution order and frequency distribution of runtime API Calls.
In the first experiment, we applied the proposed birthmarks to the same-purpose applications.
As a result, it was shown that an application and its extended version have quite similar birthmarks, and that the applications that are independently implemented possess significantly different birthmarks.
The second experiment showed that the proposed birthmarks achieve the strong resilience against the usage of different compilers and optimizations.&lt;/p&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/dynamic_birthmarks/features.png"/></item><item><title>Concept of Birthmarks</title><link>https://tamada.github.io/research/birthmark_concept/</link><pubDate>Thu, 01 Sep 2005 00:00:00 +0000</pubDate><guid>https://tamada.github.io/research/birthmark_concept/</guid><description>&lt;h2 class="relative group"&gt;:speaking_head: Overview
 &lt;div id="speaking_head-overview" class="anchor"&gt;&lt;/div&gt;
 
 &lt;span
 class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"&gt;
 &lt;a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#speaking_head-overview" aria-label="Anchor"&gt;#&lt;/a&gt;
 &lt;/span&gt;
 
&lt;/h2&gt;
&lt;p&gt;To detect the theft of Java class files efficiently, we propose a concept of &lt;em&gt;Java birthmarks&lt;/em&gt;, which are unique and native characteristics of every class file.
For a pair of class files $p$ and $q$, if $q$ has the same birthmark as $p$&amp;rsquo;s, $q$ is suspected as a &lt;em&gt;copy&lt;/em&gt; of $p$.
Ideally, the birthmarks should satisfy the following properties: (a) &lt;em&gt;preservation&lt;/em&gt; &amp;ndash; the birthmarks should be preserved even if the original class file is tampered with, and (b) &lt;em&gt;distinction&lt;/em&gt; &amp;ndash; independent class files must be distinguished by completely different birthmarks.
Taking (a) and (b) into account, we propose four types of birthmarks for Java class files.&lt;/p&gt;</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://tamada.github.io/research/birthmark_concept/features.png"/></item></channel></rss>