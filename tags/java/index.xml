<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on Haruaki TAMADA</title>
    <link>https://tamada.github.io/tags/java/</link>
    <description>Recent content in java on Haruaki TAMADA</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://tamada.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>:coffee: How to get the version defined in pom.xml</title>
      <link>https://tamada.github.io/blog/20211104_vfp/</link>
      <pubDate>Thu, 04 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tamada.github.io/blog/20211104_vfp/</guid>
      <description>Overview Getting ways of the version defined in pom.xml  Constant Property Package Module   What the case in the use of native-image?  Result of Measurements   Summary Appendix (2023-01-09追記) References  Overview Java 17 が出たことだし，いい加減に Java のモジュールシステムを本格的に使いだそうとしている． 最近の Java の自作ツールは一応モジュール対応にしたつもり（pochi，vhcなど）． さらに，GraalVM を使ってネイティブイメージも作成できるそうなので色々とやってみたい．
で，アプリを作るときにバージョン情報を取得したいことがある． そして，具体的なバージョン番号は，ビルドツールのプロジェクトディスクリプタ（Maven ならpom.xml，Gradle ならbuild.gradle?）に書くことが多い． バージョン番号が複数箇所に書かれていると，更新ミスでバージョンのミスマッチが起こるので，バージョン番号は一箇所で管理したいのが人情である． となると，どのような方法でバージョン番号を取得すれば良いのだろうと思い，調べてみた． これまでは特に意識せずプロパティから読み込んだり，Packageクラスを使ったりしていた． しかし，実行方法（-jarや--module）の違いやパッケージングの方法の違いで，取得できないことがあるのかを調べてみた．
私がよく使うビルドツールは Maven であるので，pom.xml で設定したバージョン情報をアプリケーションからどんな情報で取得できるかを確認してみた． Gradle の場合でもバージョン番号を埋め込む方法に多少の違いがあるだけで，大きな違いはない．
Getting ways of the version defined in pom.xml バージョン番号を取得する方法は，次の 4 つの方法に分類できる．</description>
    </item>
    
    <item>
      <title>Obfuscation by invokedynamic</title>
      <link>https://tamada.github.io/research/obfuscation_by_invokedynamic/</link>
      <pubDate>Sat, 01 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tamada.github.io/research/obfuscation_by_invokedynamic/</guid>
      <description>:speaking_head: Overview This paper proposes an obfuscation method against illegal analysis. The proposed method tries to build a fake call flow graph from debugging tools. The call flow graph represents relations among methods and helps understanding of a program. The fake call flow graph leads misunderstanding of the program. We focus on a hook mechanism of the method call for changing a callee. We conduct two experiments to evaluate the proposed method.</description>
    </item>
    
    <item>
      <title>Method folding obfuscation</title>
      <link>https://tamada.github.io/research/obfuscation_by_method_folding/</link>
      <pubDate>Mon, 01 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>https://tamada.github.io/research/obfuscation_by_method_folding/</guid>
      <description>:speaking_head: Overview To improve tamper resistance of programs against illegal modification, this paper proposes instruction folding applicable to Java platform.
In the proposed method, at first, similar methods are selected in a Java program. Next, these methods are merged into one method and diffs among these methods are stored in the program. Then, at runtime, when one of the merged methods is executed, diffs are restored by self-modification, which is realized by the Java instrumentation mechanism.</description>
    </item>
    
    <item>
      <title>Obfuscation by dynamic name resolution</title>
      <link>https://tamada.github.io/research/obfuscation_by_dnr/</link>
      <pubDate>Tue, 12 Feb 2008 00:00:00 +0000</pubDate>
      
      <guid>https://tamada.github.io/research/obfuscation_by_dnr/</guid>
      <description>:speaking_head: Overview Name obfuscation is a software protection technique, which renames identifiers in a given program, to protect the program from illegal cracking. The conventional methods replace names appearing in the declaration part with the meaningless ones. Therefore, the methods cannot be used to obfuscate names declared in system libraries, since changing such system-defined names significantly deteriorates the program portability.
This paper presents a new name obfuscation method, which can hide appearance of the system-defined names.</description>
    </item>
    
  </channel>
</rss>
